package mills.index1.partitions;

import mills.bits.PGroup;
import mills.ring.EntryTable;
import mills.ring.RingEntry;
import mills.util.AbstractRandomList;

import java.util.*;
import java.util.function.Predicate;

/**
 * Created by IntelliJ IDEA.
 * User: stueken
 * Date: 09.09.2010
 * Time: 15:23:46
 */

/**
 * A PartitionTable provides a list of 128 RingTables for a given restriction mask [0,128[
 * Each partition contains minimized ring entries only.
 *
 * Each Partition is generated by an appropriate PartitionFilter.
 */
public class PartitionTable extends AbstractRandomList<EntryTable> {

    public static final PartitionTable EMPTY = new PartitionTable();

    private final EntryTable table[];

    public List<EntryTable> tables;

    @Override
    public EntryTable get(int index) {
        return table[index];
    }

    @Override
    public int size() {
        return 128;
    }

    private PartitionTable(EntryTable table[], List<EntryTable> tables) {
        assert table.length == 128 : String.format("unexpected size: %d!=128", table.length);
        this.table = table;
        this.tables = List.copyOf(tables);
    }

    private PartitionTable() {
        table = new EntryTable[128];
        Arrays.fill(table, EntryTable.EMPTY);
        this.tables = Collections.emptyList();
    }

    /**
     * Generate a partition table for a given list of RingEntries.
     * @param root set of entries to partition.
     * @return a new PartitionTable.
     */
    public static PartitionTable build(final EntryTable root) {

        if(root.isEmpty())
            return EMPTY;

        final Set<PGroup> groups = PGroup.groups(root);

        EntryTable[] table = new EntryTable[128];
        List<EntryTable> tables = new ArrayList<>(20);

        // populate all partitions
        for(int msk=0; msk<128; ++msk) {

            EntryTable et = table[msk];
            if(et!=null)
                continue;   // done

            // get part mask which may have been already calculated.
            int part = PGroup.pindex(groups, msk);

            et = table[part];
            if(et==null) {
                // generate a new partition
                final Predicate<RingEntry> f = PartitionFilter.of(msk);
                et = root.filter(f);
                table[part] = et;
                tables.add(et);
            }

            if(part!=msk)
                table[msk] = et;
        }

        return new PartitionTable(table, tables);
    }
}
