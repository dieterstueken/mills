package mills.index1.partitions;

import mills.bits.PGroup;
import mills.ring.EntryTable;
import mills.ring.RingEntry;
import mills.util.AbstractRandomList;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;
import java.util.Set;
import java.util.function.Function;
import java.util.function.Predicate;
import java.util.function.UnaryOperator;

/**
 * Created by IntelliJ IDEA.
 * User: stueken
 * Date: 09.09.2010
 * Time: 15:23:46
 */

/**
 * A PartitionTable provides a list of 128 RingTables for a given restriction mask [0,128[
 * Each partition contains minimized ring entries only.
 *
 * Each Partition is generated by an appropriate PartitionFilter.
 */
public class PartitionTable<T> extends AbstractRandomList<T> {

    private final byte[] table;

    public final List<T> tables;

    @Override
    public T get(int index) {
        return tables.get(table[index]);
    }

    @Override
    public int size() {
        return 128;
    }

    private PartitionTable(byte table[], List<T> tables) {
        assert table.length == 128 : String.format("unexpected size: %d!=128", table.length);
        this.table = table;
        this.tables = List.copyOf(tables);
    }

    static <T> PartitionTable<T> empty(T empty) {
        return new PartitionTable<T>(new byte[128], List.of(empty));
    }

    public static PartitionTable<EntryTable> build(EntryTable root) {
        return build(root, UnaryOperator.identity());
    }

    /**
     * Generate a partition table for a given list of RingEntries.
     * @param root set of entries to partition.
     * @return a new PartitionTable.
     */
    public static <T> PartitionTable<T> build(EntryTable root, Function<EntryTable, T> generate) {

        final Set<PGroup> groups = PGroup.groups(root);

        byte[] table = new byte[128];
        Arrays.fill(table, (byte)-1);
        List<T> tables = new ArrayList<>(20);

        // populate all partitions
        for(int msk=127; msk>=0; --msk) {

            // get part mask which may have been already calculated.
            int part = PGroup.pindex(groups, msk);
            if(part>msk) {
                table[msk] = table[part];
            } else {
                // generate a new partition
                final Predicate<RingEntry> f = partitionFilter(msk);
                EntryTable et = root.filter(f);

                // register new table
                int k = tables.size();
                tables.add(generate.apply(et));
                table[part] = (byte)k;
            }
        }

        return new PartitionTable<>(table, tables);
    }

    private static Predicate<RingEntry> partitionFilter(int index) {
        return entry -> (entry.pmin() & 2*index) == 0;
    }
}
