package mills.index.partitions;

import com.google.common.base.Predicate;
import mills.bits.PGroup;
import mills.ring.EntryTable;
import mills.ring.RingEntry;
import mills.util.AbstractRandomList;

import java.util.Arrays;

/**
 * Created by IntelliJ IDEA.
 * User: stueken
 * Date: 09.09.2010
 * Time: 15:23:46
 */

/**
 * A PartitionTable provides a list of 128 RingTables for a given restriction mask [0,128[
 * Each partition contains minimized ring entries only.
 *
 * Each Partition is generated by an appropriate PartitionFilter.
 */
public class PartitionTable extends AbstractRandomList<EntryTable> {

    public static final PartitionTable EMPTY = new PartitionTable();

    private final EntryTable table[];

    @Override
    public EntryTable get(int index) {
        return table[index];
    }

    @Override
    public int size() {
        return 128;
    }

    private PartitionTable(EntryTable table[]) {
        assert table.length == 128 : String.format("unexpected size: %d!=128", table.length);
        this.table = table;
    }

    private PartitionTable() {
        table = new EntryTable[128];
        Arrays.fill(table, EntryTable.EMPTY);
    }

    /**
     * Generate a partition table for a given list of RingEntries.
     * @param root set of entries to partition.
     * @return a new PartitionTable.
     */
    public static PartitionTable build(final EntryTable root) {

        if(root.isEmpty())
            return EMPTY;

        final PGroup.Set groups = PGroup.Set.of(root);

        EntryTable[] table = new EntryTable[128];

        // populate all partitions
        for(int msk=0; msk<128; ++msk) {

            EntryTable et = table[msk];
            if(et!=null)
                continue;   // done

            // get part mask which may have been already calculated.
            int part = groups.partition(msk);

            et = table[part];
            if(et==null) {
                // generate a new partition
                final Predicate<RingEntry> f = PartitionFilter.of(msk);
                et = root.filter(f);
                table[part] = et;
            }

            if(part!=msk)
                table[msk] = et;
        }

        return new PartitionTable(table);
    }
}
